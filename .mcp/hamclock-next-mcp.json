{
  "mcp_version": "2.0",
  "project": "hamclock-next",
  "updated_at": "2026-02-15T00:00:00.000Z",

  "project_context": {
    "title": "HamClock Next — SDL2 Rewrite",
    "callsign": "K4DRW",
    "repository": "https://github.com/k4drw/hamclock",
    "active_branch": "hamclock-next",
    "legacy_branch": "master",
    "origin": "This project is a full rewrite of Elwood Downey (W7EW)'s HamClock, a feature-rich amateur radio dashboard originally targeting ESP32 and Raspberry Pi via a custom framebuffer/X11 rendering stack. Elwood became a Silent Key on 29 January 2026. This rewrite is dedicated to his memory.",
    "why_rewrite": "The original codebase accumulated ~1.2 million lines across monolithic files (setup.cpp alone is 207K). Incremental patching was unsustainable. The rewrite adopts SDL2, separates concerns into widget classes, uses libcurl/libpredict instead of custom protocol stacks, and targets any SDL2-capable desktop or embedded Linux system.",
    "philosophy": [
      "Each feature is a self-contained Widget class with a consistent interface.",
      "Data fetching is separated from rendering: every widget has a *Provider (services/) and a *Panel (ui/).",
      "Core data structures live in src/core/ as plain data types.",
      "Infrastructure (WebServer, NetworkManager, ConfigManager) is shared.",
      "The layout is fluid/responsive — not hardcoded to 800x480 like the original.",
      "SDL2 RGBA replaces RGB565. SDL_ttf replaces all custom font/segment renderers.",
      "libpredict v2 replaces Plan 13 for satellite orbit propagation.",
      "libcurl with ETag/Last-Modified caching replaces the custom WiFi/HTTP stack.",
      "JSON config replaces NVRAM and ESP32-specific storage."
    ],
    "tech_stack": {
      "rendering": "SDL2 + SDL_ttf + SDL_image",
      "networking": "libcurl (HTTP), POSIX sockets (Telnet/DX Cluster)",
      "orbital_mechanics": "libpredict v2 (replaces Plan 13 / P13.cpp)",
      "config": "JSON file on disk via ConfigManager",
      "web_api": "Embedded HTTP server (src/network/WebServer), documented in API.md",
      "build": "CMake",
      "language": "C++17"
    }
  },

  "source_layout": {
    "description": "Directory structure of the hamclock-next codebase. Every directory has a clear single responsibility.",
    "tree": {
      "src/": "Root source directory",
      "src/main.cpp": "Entry point. Initializes SDL2, ConfigManager, WebServer, then enters the main event/render loop.",
      "src/core/": "Pure data types, store classes, and shared utilities. No SDL or network calls here.",
      "src/ui/": "All Widget/Panel classes. Each file is a self-contained renderable unit.",
      "src/services/": "Data providers. Each provider fetches and caches data for one domain.",
      "src/network/": "NetworkManager (HTTP/curl) and WebServer (embedded REST API)."
    },
    "naming_conventions": {
      "widget_pair": "Every panel that displays data has a {Name}Panel.cpp/.h (rendering) paired with a {Name}Provider.cpp/.h (data).",
      "data_struct": "Data structures live in src/core/ as {Name}Data.h or {Name}Store.h.",
      "infrastructure": "Singleton-style managers: ConfigManager, NetworkManager, WebServer, UIRegistry.",
      "original_vs_next": "Original used flat .cpp files with global functions. Next uses classes. Example: original updateDXCluster() global → next DXClusterProvider::update() + DXClusterPanel::render()."
    }
  },

  "widget_scaffolding": {
    "description": "The fastest way to add a new widget or complete a partial one. Follow these steps and fill in the domain-specific logic.",
    "steps": [
      "1. Create src/core/{Name}Data.h — plain struct with the data fields the widget displays.",
      "2. Create src/services/{Name}Provider.h/.cpp — fetches data via NetworkManager, stores in {Name}Data.",
      "3. Create src/ui/{Name}Panel.h/.cpp — renders the data using SDL2. Inherits or follows the Widget interface.",
      "4. Register the widget in src/core/WidgetType.h and src/core/UIRegistry.h.",
      "5. If the widget exposes map overlays, integrate with MapWidget::render().",
      "6. Add REST endpoints to WebServer if needed (follow API.md conventions).",
      "7. Update feature_map.json status from 'partial'/'missing' to 'implemented' when acceptance criteria are met."
    ],
    "data_template": "// src/core/{Name}Data.h\n#pragma once\n#include <string>\n#include <vector>\n#include <ctime>\n\nstruct {Name}Data {\n    // --- domain fields ---\n    bool valid = false;       // set true once first fetch succeeds\n    time_t lastUpdate = 0;    // unix timestamp of last successful fetch\n};\n",
    "provider_template": "// src/services/{Name}Provider.h\n#pragma once\n#include \"core/{Name}Data.h\"\n\nclass {Name}Provider {\npublic:\n    static {Name}Provider& instance();\n    void update();               // called on interval by main loop\n    const {Name}Data& data() const { return _data; }\nprivate:\n    {Name}Provider() = default;\n    {Name}Data _data;\n    time_t _nextFetch = 0;\n    static constexpr int FETCH_INTERVAL_S = 300;\n};\n",
    "panel_template": "// src/ui/{Name}Panel.h\n#pragma once\n#include <SDL2/SDL.h>\n#include \"services/{Name}Provider.h\"\n\nclass {Name}Panel {\npublic:\n    void setBounds(SDL_Rect r) { _bounds = r; }\n    void render(SDL_Renderer* ren);\n    bool onTouch(int x, int y);  // return true if consumed\n    std::string getDebugData() const;\nprivate:\n    SDL_Rect _bounds{};\n};\n",
    "important_notes": [
      "NetworkManager handles HTTP. Call NetworkManager::instance().get(url) — it returns cached data when ETag/Last-Modified hasn't changed.",
      "ConfigManager::instance().get(key, default) for reading user settings. ConfigManager::instance().set(key, value) + save() to persist.",
      "Theme.h has all color constants. Use Theme::TEXT, Theme::ACCENT, etc. — never hardcode SDL_Color values.",
      "FontManager handles scaled TTF fonts. Never load your own TTF file.",
      "SDL coordinates: (0,0) is top-left. _bounds.x/y is the panel's top-left corner.",
      "All render() calls happen on the main thread. Providers run on a background thread. Use a mutex or std::atomic if sharing state.",
      "The WebServer debug endpoint /debug/widgets calls getDebugData() on all registered panels — always implement it."
    ]
  },

  "api_reference": {
    "description": "The embedded WebServer exposes a REST API. Full docs in API.md in the repo root. Key endpoints for contributor awareness:",
    "base_url": "http://localhost:{port}",
    "endpoints": [
      { "method": "GET", "path": "/live.jpg", "description": "JPEG screenshot of current display. Used by remote clients." },
      { "method": "GET", "path": "/debug/widgets", "description": "JSON dump of all registered widgets and their getDebugData() output." },
      { "method": "GET", "path": "/debug/click", "description": "Simulates a touch event at x,y. Params: ?x=N&y=N" },
      { "method": "GET", "path": "/set_touch", "description": "Inject touch event. Params: ?x=N&y=N" },
      { "method": "GET", "path": "/set_char", "description": "Inject keyboard character. Params: ?c=X" },
      { "method": "GET", "path": "/get_dx.txt", "description": "Returns DX location: grid, lat, lon, distance (km), bearing (degrees)." },
      { "method": "GET", "path": "/set_mappos", "description": "Programmatically set DE or DX position. Params: ?lat=F&lon=F&target=de|dx — returns JSON with computed Maidenhead grid." }
    ],
    "conventions": [
      "All write endpoints should eventually be protected by token auth (password_auth feature — currently missing).",
      "Return JSON for structured data, plain text for simple values.",
      "New endpoints should follow the existing naming pattern and be documented in API.md."
    ]
  },

  "original_vs_next": {
    "description": "Key architectural differences between Elwood's original and hamclock-next. Essential context for anyone touching both codebases.",
    "differences": [
      {
        "aspect": "Rendering Backend",
        "original": "Custom framebuffer abstraction + X11/EGL/ESP32 display HAL. RGB565 color format.",
        "next": "SDL2 with full RGBA. SDL_ttf for fonts, SDL_image for textures. Runs anywhere SDL2 runs."
      },
      {
        "aspect": "Code Organization",
        "original": "Flat directory of .cpp files, many 30K–207K lines. Global functions, global state.",
        "next": "Layered: core/ → services/ → ui/ → network/. Class-per-widget. No globals except singletons."
      },
      {
        "aspect": "Font / Text Rendering",
        "original": "Custom seven-segment renderer (sevenseg.cpp), custom font bitmaps.",
        "next": "SDL_ttf with FontManager. seven_segment feature is not_needed — TTF fonts cover all cases."
      },
      {
        "aspect": "Satellite Tracking",
        "original": "Plan 13 orbital propagation (P13.cpp). P13 is a classic algorithm from 1983.",
        "next": "libpredict v2 (modern successor to P13). Same math, cleaner API, actively maintained."
      },
      {
        "aspect": "Configuration Storage",
        "original": "NVRAM abstraction (nvram.cpp) — maps to ESP32 Preferences or flat file. setup.cpp is 207K.",
        "next": "JSON file via ConfigManager. setup.cpp equivalent is SetupScreen.cpp — a fraction of the size."
      },
      {
        "aspect": "Networking",
        "original": "wifi.cpp (78K) — custom HTTP stack, WiFi management for ESP32, connection pooling.",
        "next": "libcurl via NetworkManager. ETag/Last-Modified caching built in. libcurl handles TLS, redirects, timeouts."
      },
      {
        "aspect": "Web Server",
        "original": "webserver.cpp (142K) + liveweb.cpp (32K). Monolithic handler.",
        "next": "WebServer.cpp — lean, documented REST API. Endpoints registered per-feature."
      },
      {
        "aspect": "Layout",
        "original": "Hardcoded 800x480 (ESP32 display size). Pixel positions are magic numbers throughout.",
        "next": "LayoutManager + PaneContainer. Responsive. Widgets get a setBounds(SDL_Rect) call."
      },
      {
        "aspect": "Hardware Features",
        "original": "I2C BME280, CPU temp via sysfs, GPIO brightness PWM, GPS NMEA, OTA firmware update.",
        "next": "Desktop-first. Hardware features (BME280, GPS, brightness PWM, OTA) are missing — low priority unless RPi-specific build target is added."
      },
      {
        "aspect": "Map Projections",
        "original": "Azimuthal equidistant (primary), Robinson, Mercator, sphere projection.",
        "next": "Azimuthal equidistant (Phase 26: high-fidelity with NASA Black Marble night lights). Robinson and Mercator are missing."
      }
    ]
  },

  "feature_status_summary": {
    "total": 55,
    "implemented": 24,
    "partial": 21,
    "missing": 8,
    "not_needed": 2,
    "percent_done": "~72% (implemented + not_needed / total)"
  },

  "implemented_features": [
    { "feature_id": "clock_callsign", "name": "Clock & Callsign Display", "next_files": ["src/ui/CallsignClock.cpp", "src/ui/TimePanel.cpp", "src/ui/ClockAuxPanel.cpp"], "notes": "Split into 3 widgets. Stopwatch is in CountdownPanel." },
    { "feature_id": "world_map", "name": "World Map", "next_files": ["src/ui/MapWidget.cpp", "src/ui/MapWidget.h"], "notes": "Phase 26 complete: azimuthal projection, NASA Blue Marble + Black Marble night lights, day/night terminator, great circles, tooltips, DE/DX markers. Missing: Robinson, Mercator projections." },
    { "feature_id": "de_info", "name": "DE Info Panel", "next_files": ["src/ui/DEInfo.cpp", "src/ui/DEInfo.h"] },
    { "feature_id": "dx_info", "name": "DX Info Panel", "next_files": ["src/ui/DXPanel.cpp", "src/ui/DXPanel.h"] },
    { "feature_id": "live_spots", "name": "Live Spots (PSK Reporter/WSPR)", "next_files": ["src/services/LiveSpotProvider.cpp", "src/ui/LiveSpotPanel.cpp"], "notes": "Band-coded Great Circle paths on map. PSK Reporter API working." },
    { "feature_id": "dst_index", "name": "Geomagnetic Disturbance (Dst)", "next_files": ["src/ui/DstPanel.cpp", "src/core/DstStore.h"] },
    { "feature_id": "moon", "name": "Moon Phase & Position", "next_files": ["src/services/MoonProvider.cpp", "src/ui/MoonPanel.cpp"], "notes": "Includes EME path loss." },
    { "feature_id": "weather_dx", "name": "Weather at DX Location", "next_files": ["src/ui/DXPanel.cpp", "src/ui/DXSatPane.cpp"], "notes": "Integrated into DXPanel. Temp/Hum/Pressure/Wind displayed." },
    { "feature_id": "sdo_images", "name": "SDO Solar Images", "next_files": ["src/services/SDOProvider.cpp", "src/ui/SDOPanel.cpp"] },
    { "feature_id": "drap", "name": "D-Region Absorption Predictions", "next_files": ["src/services/DRAPProvider.cpp", "src/ui/DRAPPanel.cpp"] },
    { "feature_id": "aurora", "name": "Aurora Forecast", "next_files": ["src/services/AuroraProvider.cpp", "src/ui/AuroraPanel.cpp"] },
    { "feature_id": "rss_banner", "name": "RSS News Banner", "next_files": ["src/services/RSSProvider.cpp", "src/ui/RSSBanner.cpp"] },
    { "feature_id": "web_server", "name": "Embedded Web Server", "next_files": ["src/network/WebServer.cpp", "src/network/WebServer.h"], "notes": "Full API in API.md. Phase 4 endpoints added: /get_dx.txt, /set_mappos." },
    { "feature_id": "network_manager", "name": "Network Manager", "next_files": ["src/network/NetworkManager.cpp", "src/network/NetworkManager.h"], "notes": "libcurl + ETag/Last-Modified caching." },
    { "feature_id": "dxpeditions", "name": "DXpedition Tracker", "next_files": ["src/ui/ActivityPanels.cpp", "src/ui/ActivityPanels.h"], "notes": "Implemented as DXPedPanel inside ActivityPanels." },
    { "feature_id": "watchlist", "name": "Callsign Watchlist", "next_files": ["src/ui/WatchlistPanel.cpp", "src/core/WatchlistStore.h", "src/core/WatchlistHitStore.h"] },
    { "feature_id": "eme_tool", "name": "EME Tool", "next_files": ["src/ui/EMEToolPanel.cpp", "src/core/MoonData.h"] },
    { "feature_id": "santa_tracker", "name": "Santa Tracker", "next_files": ["src/core/SantaStore.h", "src/ui/MapWidget.cpp"], "notes": "Active Dec 24/25. Overlay on MapWidget." },
    { "feature_id": "history_panel", "name": "History Panel", "next_files": ["src/services/HistoryProvider.cpp", "src/ui/HistoryPanel.cpp"], "notes": "New in hamclock-next. No original equivalent." },
    { "feature_id": "local_panel", "name": "Local Info Panel", "next_files": ["src/ui/LocalPanel.cpp"], "notes": "New in hamclock-next." },
    { "feature_id": "list_panel", "name": "Generic List Panel (infrastructure)", "next_files": ["src/ui/ListPanel.cpp"] },
    { "feature_id": "pane_container", "name": "Pane Container / Layout", "next_files": ["src/ui/PaneContainer.cpp", "src/ui/LayoutManager.h"] },
    { "feature_id": "debug_overlay", "name": "Debug Overlay", "next_files": ["src/ui/DebugOverlay.h"] },
    { "feature_id": "color_theme", "name": "Color Theme System", "next_files": ["src/core/Theme.h"], "notes": "Use Theme:: constants. Never hardcode SDL_Color." }
  ],

  "partial_features": {
    "description": "These features have scaffolding in place but do NOT yet meet all acceptance criteria. These are the primary TODO items for contributors.",
    "items": [
      {
        "feature_id": "satellite_tracking",
        "name": "Satellite Tracking",
        "next_files": ["src/core/SatelliteManager.cpp", "src/ui/SatPanel.cpp", "src/ui/DXSatPane.cpp", "src/core/OrbitPredictor.cpp"],
        "original_reference": "earthsat.cpp (76K), P13.cpp, sattool.cpp",
        "what_exists": "SatelliteManager, SatPanel, DXSatPane, OrbitPredictor classes exist. libpredict v2 used instead of P13.",
        "what_is_needed": "Verify TLE fetching and update cycle. Complete polar plot rendering in SatPanel. Satellite footprint overlay on MapWidget. Rise/set prediction display. Satellite selection UI (sattool equivalent).",
        "acceptance_criteria": [
          "Satellite selection from TLE catalog",
          "Real-time position tracking on map",
          "Polar plot showing current pass",
          "Rise/set time predictions",
          "Satellite footprint on map",
          "Next-pass scheduling"
        ]
      },
      {
        "feature_id": "dx_cluster",
        "name": "DX Cluster",
        "next_files": ["src/services/DXClusterProvider.cpp", "src/ui/DXClusterPanel.cpp", "src/ui/DXClusterSetup.cpp", "src/core/DXClusterData.h"],
        "original_reference": "dxcluster.cpp (40K)",
        "what_exists": "Provider, Panel, Setup, and Data classes exist.",
        "what_is_needed": "Verify Telnet connection to cluster nodes. Spot parsing (DX de spotter freq comment). Map overlay with bearing lines. Auto-reconnect logic. Cluster node config UI.",
        "acceptance_criteria": [
          "Connect to DX Cluster node via Telnet",
          "Parse and display DX spots in scrollable list",
          "Spots plotted on map with bearing lines",
          "Cluster node configuration (host/port/login)",
          "Auto-reconnect on disconnect"
        ]
      },
      {
        "feature_id": "solar_flux",
        "name": "Solar Flux (SFI) Plot",
        "next_files": ["src/ui/SolarPanel.cpp", "src/core/SolarData.h"],
        "original_reference": "spacewx.cpp (63K), symbol PLOT_CH_FLUX",
        "what_is_needed": "Verify SolarPanel implements full 30-day time-series plot, not just current value. NOAA/SWPC data source.",
        "acceptance_criteria": [
          "30-day SFI time-series plot",
          "Current SFI value prominently shown",
          "Color coding for propagation conditions"
        ]
      },
      {
        "feature_id": "kp_index",
        "name": "Planetary K-Index",
        "next_files": ["src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_KP",
        "what_is_needed": "Confirm SpaceWeatherPanel renders Kp bar chart. Storm level indicators G1-G5. NOAA/SWPC data source.",
        "acceptance_criteria": [
          "Color-coded Kp bar chart",
          "Current Kp value",
          "Storm-level indicators (G1-G5)"
        ]
      },
      {
        "feature_id": "sunspot_number",
        "name": "Sunspot Number (SSN)",
        "next_files": ["src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_SSN",
        "what_is_needed": "Confirm SSN is rendered (may share SpaceWeatherPanel with Kp). NOAA/SWPC data.",
        "acceptance_criteria": [
          "SSN time-series plot",
          "Current SSN value shown"
        ]
      },
      {
        "feature_id": "xray_flux",
        "name": "X-Ray Flux",
        "next_files": ["src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_XRAY",
        "what_is_needed": "GOES X-ray data from NOAA/SWPC. Flare class indicators (C/M/X class flares). Time-series plot.",
        "acceptance_criteria": [
          "GOES X-ray time-series",
          "Flare class indicators (C/M/X)",
          "Current flux level shown"
        ]
      },
      {
        "feature_id": "solar_wind",
        "name": "Solar Wind",
        "next_files": ["src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_SOLWIND",
        "what_is_needed": "DSCOVR/ACE solar wind data. Speed and density time-series.",
        "acceptance_criteria": [
          "Solar wind speed and density time-series",
          "Current values shown"
        ]
      },
      {
        "feature_id": "bz_bt",
        "name": "Bz/Bt Interplanetary Magnetic Field",
        "next_files": ["src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_BZBT",
        "what_is_needed": "IMF Bz and Bt from NOAA/SWPC. Southward Bz (negative) is the key geomagnetic storm driver — highlight it.",
        "acceptance_criteria": [
          "Bz and Bt time-series",
          "Southward Bz highlighted as storm indicator"
        ]
      },
      {
        "feature_id": "noaa_space_weather",
        "name": "NOAA Space Weather Scales",
        "next_files": ["src/services/NOAAProvider.cpp", "src/ui/SpaceWeatherPanel.cpp"],
        "original_reference": "spacewx.cpp, symbol PLOT_CH_NOAASPW",
        "what_is_needed": "NOAAProvider fetches R/S/G scales. SpaceWeatherPanel renders color-coded current levels.",
        "acceptance_criteria": [
          "R (radio blackout), S (solar radiation), G (geomagnetic) levels displayed",
          "Color-coded alert status"
        ]
      },
      {
        "feature_id": "band_conditions",
        "name": "Band Conditions (VOACAP)",
        "next_files": ["src/services/BandConditionsProvider.cpp", "src/ui/BandConditionsPanel.cpp", "src/core/BandConditionsData.h"],
        "original_reference": "bands.cpp (7K), symbol PLOT_CH_BC",
        "what_is_needed": "VOACAP API query for DE-DX path. Per-band reliability bars (160m–6m). Update when DX location changes.",
        "acceptance_criteria": [
          "VOACAP predictions per band",
          "Color-coded reliability bars",
          "Updates on DX location change"
        ]
      },
      {
        "feature_id": "weather_de",
        "name": "Weather at DE Location",
        "next_files": ["src/services/WeatherProvider.cpp", "src/ui/WeatherPanel.cpp"],
        "original_reference": "wx.cpp (30K), symbol PLOT_CH_DEWX",
        "what_is_needed": "WeatherProvider completeness unclear. Verify temperature, humidity, wind, conditions display. Auto-update interval.",
        "acceptance_criteria": [
          "Temperature, humidity, wind, conditions for DE location",
          "Periodic auto-update"
        ]
      },
      {
        "feature_id": "contests",
        "name": "Contest Calendar",
        "next_files": ["src/services/ContestProvider.cpp", "src/ui/ContestPanel.cpp", "src/core/ContestData.h"],
        "original_reference": "contests.cpp (22K), symbol PLOT_CH_CONTESTS",
        "what_is_needed": "Contest data source/API. Scrollable list with name, dates, mode, bands. Highlight active contests.",
        "acceptance_criteria": [
          "Contest list with name, dates, mode, bands",
          "Active contests highlighted",
          "Tappable for details"
        ]
      },
      {
        "feature_id": "on_the_air",
        "name": "On The Air (POTA/SOTA)",
        "next_files": ["src/services/ActivityProvider.cpp", "src/ui/ActivityPanels.cpp", "src/core/ActivityData.h"],
        "original_reference": "ontheair.cpp (27K), symbol PLOT_CH_ONTA",
        "what_is_needed": "POTA and SOTA APIs. Activator list with callsign, reference, frequency, mode. Map spots. Toggle between POTA and SOTA.",
        "acceptance_criteria": [
          "POTA activator list from API",
          "SOTA activator list from API",
          "Spots on map",
          "POTA/SOTA toggle"
        ]
      },
      {
        "feature_id": "adif",
        "name": "ADIF Log Viewer",
        "next_files": ["src/services/ADIFProvider.cpp", "src/ui/ADIFPanel.cpp"],
        "original_reference": "adif.cpp (16K) + adif_parser.cpp (24K), symbol PLOT_CH_ADIF",
        "what_is_needed": "ADIF file parsing (the format is well-documented). QSO list with callsign/date/band/mode. Map overlay of QSO locations. File selection dialog.",
        "acceptance_criteria": [
          "Parse ADIF files",
          "QSO list display",
          "QSO locations on map",
          "Filter by band/mode/date"
        ]
      },
      {
        "feature_id": "ncdxf_beacons",
        "name": "NCDXF Beacon Monitor",
        "next_files": ["src/services/BeaconProvider.h", "src/ui/BeaconPanel.cpp", "src/core/BeaconData.h"],
        "original_reference": "ncdxf.cpp (10K), symbol BRB_SHOW_BEACONS",
        "what_is_needed": "BeaconProvider.h exists but no .cpp — likely incomplete. NCDXF beacon schedule is published and deterministic (time-based, no API needed). Implement schedule logic. Highlight currently transmitting beacon.",
        "acceptance_criteria": [
          "NCDXF beacon schedule display",
          "Currently transmitting beacon highlighted",
          "Beacon location on map",
          "Cycle through bands (14-28 MHz)"
        ]
      },
      {
        "feature_id": "countdown_timer",
        "name": "Countdown Timer",
        "next_files": ["src/ui/CountdownPanel.cpp"],
        "original_reference": "stopwatch.cpp (97K), symbol PLOT_CH_COUNTDOWN",
        "what_is_needed": "Target date/time input. Remaining time display (d/h/m/s). Visual/audio alarm at zero. Event name label.",
        "acceptance_criteria": [
          "Set target date/time",
          "Display d/h/m/s remaining",
          "Alarm at zero",
          "Configurable event name"
        ]
      },
      {
        "feature_id": "rotator_gimbal",
        "name": "Rotator/Gimbal Control",
        "next_files": ["src/ui/GimbalPanel.cpp"],
        "original_reference": "gimbal.cpp (36K), symbol PLOT_CH_GIMBAL",
        "what_is_needed": "GimbalPanel UI exists. Need hardware serial integration for rotator protocols (Yaesu GS-232, Easycomm). Compass display. Rotate-to-bearing command.",
        "acceptance_criteria": [
          "Current rotator azimuth display",
          "Rotate to target bearing command",
          "Visual compass",
          "Support GS-232 or Easycomm protocol"
        ]
      },
      {
        "feature_id": "setup_config",
        "name": "Setup & Configuration",
        "next_files": ["src/core/ConfigManager.cpp", "src/ui/SetupScreen.cpp"],
        "original_reference": "setup.cpp (207K), configs.cpp (28K), nvram.cpp (20K)",
        "what_is_needed": "SetupScreen completeness unclear. Verify all config items: callsign, location (grid/lat-lon/map-click), DX Cluster host/port, display preferences. Config persistence via ConfigManager.",
        "acceptance_criteria": [
          "Callsign entry",
          "Location setting (grid or lat/lon or map click)",
          "DX Cluster configuration",
          "Display preferences",
          "Config persisted to JSON on disk"
        ]
      },
      {
        "feature_id": "widget_selector",
        "name": "Widget/Pane Selector",
        "next_files": ["src/ui/WidgetSelector.cpp", "src/core/WidgetType.h", "src/core/UIRegistry.h"],
        "original_reference": "menu.cpp (31K), plotmgmnt.cpp (23K)",
        "what_is_needed": "Long-press/tap on pane opens selector. List available widgets. Assign widget to pane. Persist pane assignments.",
        "acceptance_criteria": [
          "Tap/long-press opens widget selector",
          "Widget list for pane",
          "Assignment replaces current widget",
          "Persisted across restarts"
        ]
      },
      {
        "feature_id": "prefix_lookup",
        "name": "Callsign Prefix Lookup",
        "next_files": ["src/core/PrefixManager.cpp"],
        "original_reference": "prefixes.cpp (41K) + callsign.cpp (20K)",
        "what_is_needed": "PrefixManager exists. Verify DXCC database is complete and returns country, CQ zone, ITU zone, and coordinates for callsign prefixes.",
        "acceptance_criteria": [
          "Callsign → DXCC entity lookup",
          "Returns country, CQ zone, ITU zone",
          "Approximate coordinates",
          "Handles special prefixes and portable suffixes"
        ]
      },
      {
        "feature_id": "maidenhead",
        "name": "Maidenhead Grid System",
        "next_files": [],
        "original_reference": "maidenhead.cpp (4K)",
        "what_is_needed": "Grid conversion functions may be embedded in SetupScreen and DEInfo. Create src/core/Maidenhead.h with standalone ll2grid(lat, lon) and grid2ll(grid) functions. Ensure consistent use across codebase.",
        "acceptance_criteria": [
          "ll2grid() and grid2ll() as standalone utility",
          "Grid square labels on map edges",
          "Grid input supported in setup screen"
        ]
      }
    ]
  },

  "missing_features": {
    "description": "These features exist in the original but have NO scaffolding in hamclock-next. Prioritize based on deployment target (desktop vs Raspberry Pi).",
    "items": [
      {
        "feature_id": "brightness_control",
        "name": "Brightness Control",
        "original_reference": "brightness.cpp (38K)",
        "priority": "medium",
        "notes": "Hardware PWM and photocell are ESP32/Pi-specific. Desktop equivalent: SDL2 window opacity or SDL_SetTextureBlendMode for a dimming overlay. Day/night schedule based on sunrise/sunset from DE location.",
        "acceptance_criteria": [
          "Manual brightness slider",
          "Day/night schedule",
          "Smooth transition"
        ]
      },
      {
        "feature_id": "radio_control",
        "name": "Radio CAT Control",
        "original_reference": "radio.cpp (21K)",
        "priority": "medium",
        "notes": "CAT control via serial/network. Consider Hamlib integration (cross-platform, supports 200+ radios) rather than reimplementing CI-V/Kenwood/Yaesu protocols from scratch.",
        "acceptance_criteria": [
          "Connect to radio via serial or network",
          "Set frequency from DX spot",
          "Display current frequency",
          "Support CI-V, Kenwood, Yaesu via Hamlib"
        ]
      },
      {
        "feature_id": "gps_nmea",
        "name": "GPS/NMEA Integration",
        "original_reference": "nmea.cpp (15K) + gpsd.cpp (7K)",
        "priority": "low",
        "notes": "More relevant for Raspberry Pi deployments. gpsd daemon interface (gpsd.cpp) is the most portable approach — connect to gpsd socket and read JSON output.",
        "acceptance_criteria": [
          "NMEA serial port reading",
          "gpsd daemon interface",
          "Auto-set DE location",
          "PPS time sync"
        ]
      },
      {
        "feature_id": "bme280_sensor",
        "name": "BME280 Environmental Sensor",
        "original_reference": "BME280.cpp (16K)",
        "priority": "low",
        "notes": "I2C hardware — only relevant for RPi with sensor. Plots temperature, pressure, humidity, dew point.",
        "acceptance_criteria": [
          "I2C BME280 read",
          "Temperature/pressure/humidity display",
          "Dew point calculation",
          "Historical plots"
        ]
      },
      {
        "feature_id": "robinson_projection",
        "name": "Robinson Map Projection",
        "original_reference": "robinson.cpp (5K)",
        "priority": "medium",
        "notes": "Robinson projection is visually familiar to users but less operationally useful for ham radio than azimuthal. Original robinson.cpp is only 5K — the math is well-documented. MapWidget would need a projection enum and renderer switch.",
        "acceptance_criteria": [
          "Robinson projection rendering",
          "Day/night terminator on Robinson",
          "Toggle between azimuthal and Robinson"
        ]
      },
      {
        "feature_id": "qrz_lookup",
        "name": "QRZ.com Callsign Lookup",
        "original_reference": "qrz.cpp (2K)",
        "priority": "low",
        "notes": "Requires QRZ.com XML subscription key. Original was only 2K — straightforward API call. Store key in ConfigManager.",
        "acceptance_criteria": [
          "Query QRZ XML API with callsign",
          "Display name, address, QSL info",
          "API key stored in config"
        ]
      },
      {
        "feature_id": "password_auth",
        "name": "Web Server Authentication",
        "original_reference": "passwd.cpp (9K)",
        "priority": "high",
        "notes": "API.md mentions future token-based auth. Control endpoints (/set_touch, /set_char, /set_mappos) allow remote input injection — these MUST be protected before any public deployment. Implement Bearer token auth at minimum.",
        "acceptance_criteria": [
          "Token/password protection for control endpoints",
          "Read-only endpoints optionally unprotected",
          "Token stored in config"
        ]
      },
      {
        "feature_id": "cpu_temp",
        "name": "CPU Temperature Monitor",
        "original_reference": "cputemp.cpp (11K)",
        "priority": "low",
        "notes": "Read from /sys/class/thermal/thermal_zone0/temp on Linux. Simple sysfs read. Useful for RPi health monitoring.",
        "acceptance_criteria": [
          "Read from /sys/class/thermal",
          "Display current CPU temperature"
        ]
      }
    ]
  },

  "not_needed_features": {
    "description": "These original features are explicitly NOT being ported. Document for contributor clarity.",
    "items": [
      {
        "feature_id": "seven_segment",
        "name": "Seven-Segment Display Renderer",
        "reason": "sevenseg.cpp (11K) rendered custom bitmap seven-segment digits. SDL2 + SDL_ttf provides proper font rendering. The aesthetic can be replicated with a seven-segment TTF font if desired, but the custom renderer is unnecessary."
      },
      {
        "feature_id": "ota_update",
        "name": "Over-The-Air Firmware Update",
        "reason": "OTAupdate.cpp (14K) was ESP32-specific — it flashed new firmware to the microcontroller. Desktop Linux does not update this way. Use OS package manager or git pull + rebuild."
      }
    ]
  },

  "contribution_guide": {
    "for_new_contributors": [
      "Read this MCP and the API.md in the repo root before touching any code.",
      "Pick a feature from partial_features — most have scaffolding already in place.",
      "Follow the widget_scaffolding steps. Do not deviate from the Provider/Panel/Data naming pattern.",
      "Use Theme:: color constants. Use FontManager for text. Never hardcode pixel positions — use _bounds from setBounds().",
      "Implement getDebugData() in every Panel — it feeds /debug/widgets and is essential for remote debugging.",
      "When a feature is complete, update feature_map.json: change status to 'implemented', verify acceptance criteria.",
      "Test with the WebServer: /live.jpg shows the current state, /debug/widgets shows widget health."
    ],
    "for_ai_assistants": [
      "This project uses C++17. Use modern C++ idioms: auto, range-for, std::optional, std::variant where appropriate.",
      "Do not suggest ESP32-specific code. This is a desktop/embedded Linux SDL2 application.",
      "When implementing a partial feature, check what already exists in the listed next_files before writing new code.",
      "The original codebase (master branch) is reference material for behavior, NOT for code style or architecture.",
      "libpredict v2 docs: https://github.com/la1k/libpredict — use for all satellite tracking math.",
      "libcurl is already integrated via NetworkManager. Do not add new HTTP libraries.",
      "SDL2 docs: https://wiki.libsdl.org/SDL2 — SDL_Renderer, SDL_Texture, SDL_ttf, SDL_image are all in use.",
      "When unsure about an API endpoint format, check API.md and follow the existing pattern in WebServer.cpp.",
      "feature_map.json is the source of truth for what is done, partial, or missing. Update it when you complete work."
    ],
    "code_style": [
      "Tabs for indentation (0x09 — the way $DEITY intended).",
      "Braces on same line for control flow, own line for class/function definitions.",
      "Class members prefixed with underscore: _bounds, _data, _nextFetch.",
      "Public API first in header, private last.",
      "No raw owning pointers — use std::unique_ptr or std::shared_ptr."
    ]
  },

  "feature_map_maintenance": {
    "description": "How to keep the MCP current as development progresses.",
    "instructions": [
      "When a partial feature's acceptance criteria are fully met, change its status to 'implemented'.",
      "When a missing feature is started, create its scaffolding files and change status to 'partial' with next.files populated.",
      "When a decision is made to permanently skip a feature, change status to 'not_needed' with a clear reason in notes.",
      "After any status change, update feature_status_summary counts.",
      "The notes field on any feature can document implementation decisions, gotchas, or references — keep it current.",
      "This file (hamclock-next-mcp.json) lives in the repo root and is the first thing AI assistants and new contributors should read."
    ]
  },

  "decisions": {
    "description": "Architectural decisions and their rationale. This section explains WHY key choices were made, not just what they are.",
    "entries": [
      {
        "id": "sdl2_over_framebuffer",
        "topic": "Rendering backend architecture",
        "decision": "Use SDL2 with RGBA rendering instead of custom framebuffer abstraction with RGB565",
        "rationale": "SDL2 provides cross-platform window management, HiDPI scaling, and hardware-accelerated rendering out of the box. The original's custom framebuffer abstraction required separate implementations for ESP32 TFT, X11, and framebuffer devices. SDL2 handles resize events natively, supports multiple displays, and provides consistent behavior across Linux, macOS, and Windows. RGB565 was chosen for the original to minimize ESP32 memory usage (2 bytes per pixel vs 4), but modern desktops have abundant RAM where RGBA's alpha channel enables proper compositing and transparency effects.",
        "alternatives_considered": ["Qt (too heavy, 50MB+ dependency)", "SFML (less mature than SDL2)", "Direct X11/Wayland (Linux-only, low-level complexity)", "Keep custom framebuffer (unmaintainable across platforms)"],
        "tradeoffs": "SDL2 adds ~1MB dependency vs custom framebuffer's zero-dependency approach. RGBA uses 2x memory per pixel vs RGB565, but this is negligible on desktop (800x480x4 = 1.5MB). Benefit: HiDPI, window resizing, and cross-platform support are handled by SDL2 instead of manual reimplementation.",
        "files": ["src/main.cpp", "src/ui/Widget.h"]
      },
      {
        "id": "libpredict_over_plan13",
        "topic": "Satellite orbit propagation library",
        "decision": "Use libpredict v2 instead of porting P13.cpp",
        "rationale": "Plan 13 is a classic 1983 algorithm implemented in the original as P13.cpp. libpredict v2 is the modern C library successor to Plan 13, actively maintained by the satellite tracking community. It provides the same SGP4 propagation math with a clean RAII-compatible API, proper TLE parsing, and extensive testing. Porting P13.cpp would mean maintaining ~500 lines of orbital mechanics code with no test coverage, while libpredict is battle-tested and used by dozens of satellite tracking applications.",
        "alternatives_considered": ["Port P13.cpp directly (maintenance burden)", "Use PyEphem via Python bindings (adds Python dependency)", "gpredict codebase (GPL license incompatible)", "Write SGP4 from scratch (weeks of work, high bug risk)"],
        "tradeoffs": "libpredict is an external dependency (~50KB) that must be installed via package manager or built from source. Benefit: professionally maintained, accurate, and well-documented. The API is C-based but wraps cleanly into OrbitPredictor RAII class.",
        "files": ["src/core/OrbitPredictor.h", "src/core/OrbitPredictor.cpp", "CMakeLists.txt"]
      },
      {
        "id": "libcurl_over_custom_wifi",
        "topic": "HTTP networking stack",
        "decision": "Use libcurl via NetworkManager instead of custom wifi.cpp HTTP implementation",
        "rationale": "The original's wifi.cpp (78K lines) implemented HTTP/1.1 from scratch to support ESP32 WiFi management and connection pooling. On desktop Linux, WiFi is managed by NetworkManager/wpa_supplicant at the OS level. libcurl handles HTTP/2, TLS 1.3, automatic redirects, cookie jars, compression, and connection pooling with a mature, audited codebase. ETag and Last-Modified caching are built into NetworkManager wrapper to minimize bandwidth for NOAA/API polling.",
        "alternatives_considered": ["Port wifi.cpp (ESP32-specific, 78K lines to maintain)", "cpp-httplib (header-only, but no caching)", "Boost.Beast (heavyweight dependency)", "Raw sockets (reinventing the wheel)"],
        "tradeoffs": "libcurl is ~500KB dependency. Benefit: TLS certificate validation, HTTP/2 multiplexing, and proxy support are all handled. NetworkManager adds ETag/Last-Modified caching layer to avoid redundant API calls.",
        "files": ["src/network/NetworkManager.h", "src/network/NetworkManager.cpp"]
      },
      {
        "id": "json_config_over_nvram",
        "topic": "Configuration persistence",
        "decision": "Use JSON file on disk (ConfigManager) instead of ESP32 NVRAM/Preferences",
        "rationale": "The original used nvram.cpp to abstract ESP32 Preferences (key-value flash storage) and Linux flat files. JSON provides human-readable config, version control compatibility, and easy backup/restore. ConfigManager loads config.json from ~/.hamclock/ (XDG-compliant path) and writes atomically to prevent corruption. JSON Schema validation could be added later for config migration.",
        "alternatives_considered": ["SQLite (overkill for <100 settings)", "INI file (no nested structures)", "Binary format (not human-editable)", "Keep NVRAM abstraction (ESP32-specific)"],
        "tradeoffs": "JSON is slightly slower to parse than binary, but config is only loaded once at startup (~5ms for typical config). Benefit: users can edit config.json in a text editor, check it into git, or script config changes.",
        "files": ["src/core/ConfigManager.h", "src/core/ConfigManager.cpp"]
      },
      {
        "id": "widget_separation",
        "topic": "Provider/Panel/Data architecture pattern",
        "decision": "Separate data fetching (Provider), rendering (Panel), and storage (Data) into distinct classes instead of monolithic feature files",
        "rationale": "The original had monolithic files like dxcluster.cpp (40K) mixing Telnet I/O, spot parsing, UI rendering, and touch handling. The rewrite separates concerns: DXClusterProvider handles Telnet, DXClusterData stores spots, DXClusterPanel renders UI. This enables: (1) unit testing providers without SDL, (2) swapping UI without touching network code, (3) multiple panels sharing the same provider, (4) background data fetching on worker threads while rendering stays on main thread.",
        "alternatives_considered": ["Keep monolithic files (unmaintainable)", "Single Widget class per feature (mixes concerns)", "Full MVC framework (too heavyweight)"],
        "tradeoffs": "More files per feature (3-4 instead of 1), but each file is focused and <300 lines. Benefit: thread safety is explicit (providers have mutexes, panels only read), testability improves, and new contributors can understand one class at a time.",
        "files": ["src/ui/Widget.h", "src/services/DXClusterProvider.cpp", "src/ui/DXClusterPanel.cpp"]
      },
      {
        "id": "responsive_layout",
        "topic": "Layout management system",
        "decision": "Use LayoutManager with proportional zones instead of hardcoded 800x480 pixel coordinates",
        "rationale": "The original assumed 800x480 display (ESP32 3.5-inch TFT) with magic number pixel positions throughout the codebase. LayoutManager divides the screen into TopBar, SidePanel, and MainStage zones, then distributes widgets proportionally by weight. When window resizes, widgets get new bounds via onResize(). Fidelity mode locks to canonical 800x480 for pixel-perfect reproduction of original layout. Responsive mode scales to any window size (tested 1920x1080, 1024x600, 800x480).",
        "alternatives_considered": ["Keep 800x480 hardcoded (breaks on modern displays)", "CSS-style flexbox (no C++ library available)", "Dear ImGui (different paradigm, heavier)", "Qt Layouts (Qt dependency)"],
        "tradeoffs": "Widgets must implement onResize() instead of assuming fixed bounds. Benefit: HamClock runs fullscreen on 1080p monitors, windowed on laptops, and letterboxed on 800x480 Pi displays without code changes.",
        "files": ["src/ui/LayoutManager.h", "src/ui/PaneContainer.h"]
      },
      {
        "id": "sdl_ttf_over_sevenseg",
        "topic": "Font rendering system",
        "decision": "Use SDL_ttf for all text instead of custom seven-segment renderer",
        "rationale": "The original's sevenseg.cpp rendered bitmap seven-segment digits for clock display. SDL_ttf provides TrueType font rendering with kerning, anti-aliasing, and Unicode support. FontManager caches rendered glyphs as SDL_Textures to avoid re-rendering on every frame. The seven-segment aesthetic can be replicated with a TTF font (e.g., DSEG) if desired, but the custom bitmap renderer is unnecessary complexity.",
        "alternatives_considered": ["Port sevenseg.cpp (9K lines, no anti-aliasing)", "FreeType directly (SDL_ttf wraps it cleanly)", "stb_truetype (header-only, but no caching)"],
        "tradeoffs": "SDL_ttf is ~100KB dependency. Benefit: professional typography, Unicode callsigns (Japanese hams!), and consistent text rendering across widgets.",
        "files": ["src/ui/FontManager.h", "src/ui/FontManager.cpp"]
      },
      {
        "id": "hono_over_express",
        "topic": "MCP server framework",
        "decision": "Use Hono instead of Express for the MCP bridge server",
        "rationale": "The MCP server (Model Context Protocol bridge) runs in Node.js to expose hamclock-next project context to AI assistants. Hono is a lightweight, edge-first framework (3KB vs Express 200KB) with better TypeScript support and modern async/await patterns. The MCP server only handles ~10 simple GET endpoints, so Express's middleware ecosystem is overkill. Hono compiles to a single-file ESM bundle that starts in <50ms.",
        "alternatives_considered": ["Express (most popular, but heavyweight)", "Fastify (faster than Express, but still 500KB)", "Raw Node http module (too low-level)"],
        "tradeoffs": "Hono has smaller ecosystem than Express, but MCP server needs zero middleware. Benefit: faster cold starts, smaller bundle size, better TypeScript inference.",
        "files": [".mcp/package.json", ".mcp/src/index.ts"]
      },
      {
        "id": "password_auth_not_needed",
        "topic": "Web API authentication decision",
        "decision": "Explicitly defer password authentication to post-v1.0 instead of implementing upfront",
        "rationale": "The original had passwd.cpp (9K) for HTTP Basic Auth to protect control endpoints. In development, the web server runs on localhost:8080 and is not exposed to the internet. For production deployments, reverse proxies (nginx, Caddy) handle TLS and auth more robustly than embedding it in the app. WebServer.h documents that control endpoints (/set_touch, /set_mappos, /set_char) should be protected before public deployment, but this is a deployment concern, not a v1.0 blocker.",
        "alternatives_considered": ["Implement HTTP Basic Auth (insecure without TLS)", "Bearer tokens (requires token management UI)", "OAuth2 (massive overkill)", "Client certificates (complex setup)"],
        "tradeoffs": "Current WebServer is INSECURE for public internet exposure. Benefit: development velocity is higher without auth complexity. Production deployments should use nginx with Basic Auth or Tailscale for zero-trust networking.",
        "files": ["src/network/WebServer.h", "src/network/WebServer.cpp"]
      }
    ]
  },

  "gotchas": {
    "description": "Hard-won debugging knowledge. These are non-obvious behaviors, footguns, and initialization order dependencies that will cost you hours if you don't know about them.",
    "entries": [
      {
        "id": "sdl_viewport_bug",
        "severity": "high",
        "component": "rendering",
        "symptom": "Clicking on widgets registers at wrong coordinates, or rendering appears shifted/clipped on some systems (especially remote X11 or non-standard DPI)",
        "cause": "SDL_RenderSetViewport() is buggy/flaky on some GL/X11 setups. The viewport transform doesn't always apply correctly to SDL_RenderReadPixels (used for /live.jpg capture) or mouse event coordinates. Instead of trusting SDL viewports, we manually calculate logical origin offsets and shift widget bounds.",
        "fix": "Do NOT use SDL_RenderSetViewport(). Instead, LayoutManager calculates offX/offY based on window size vs logical 800x480 canvas, then passes these offsets to recalculateFidelity(). All widgets receive bounds already offset. See src/main.cpp:343-345 for the viewport avoidance pattern.",
        "files": ["src/main.cpp", "src/ui/LayoutManager.h"]
      },
      {
        "id": "sdl_ttf_init_order",
        "severity": "high",
        "component": "rendering",
        "symptom": "Segfault or 'TTF_OpenFont failed' on startup",
        "cause": "SDL_ttf must be initialized AFTER SDL_Init() but BEFORE any TTF_OpenFont() calls. If FontManager tries to load fonts before TTF_Init(), you get a segfault. If you forget TTF_Quit() before SDL_Quit(), you may leak font handles.",
        "fix": "Call TTF_Init() immediately after SDL_Init(SDL_INIT_VIDEO). Call TTF_Quit() before SDL_Quit(). FontManager constructor should check TTF_WasInit() and error gracefully if not initialized. See src/main.cpp initialization sequence.",
        "files": ["src/main.cpp", "src/ui/FontManager.cpp"]
      },
      {
        "id": "render_thread_safety",
        "severity": "high",
        "component": "threading",
        "symptom": "Random crashes, texture corruption, or 'OpenGL context not current' errors",
        "cause": "SDL2 rendering (SDL_Renderer, SDL_Texture, SDL_Surface) is NOT thread-safe. All render() calls must happen on the main thread where the window was created. Providers run on background threads (via std::thread or NetworkManager async callbacks) and cannot touch SDL directly.",
        "fix": "Providers store data in plain structs (SolarData, DXClusterData, etc.) protected by std::mutex. Panels read this data on the main thread during render(). NEVER create SDL_Texture or call SDL_RenderDrawLine from a Provider. If you need to pass images from provider to panel, use raw pixel buffers and create the texture in Panel::render().",
        "files": ["src/services/NOAAProvider.cpp", "src/ui/SpaceWeatherPanel.cpp", "src/core/SolarData.h"]
      },
      {
        "id": "networkmanager_cache",
        "severity": "medium",
        "component": "networking",
        "symptom": "API data appears stale or doesn't update even after cache expiry",
        "cause": "NetworkManager caches HTTP responses with ETag/Last-Modified headers. If the API server returns '304 Not Modified', NetworkManager serves the cached response even if you passed force=true. Some APIs (e.g., NOAA SWPC) return 304 aggressively even when data has changed.",
        "fix": "For APIs that don't respect cache headers correctly, set a short cacheAgeSeconds (e.g., 300) and pass force=true when you need fresh data. Alternatively, append a cache-busting query parameter like ?t={timestamp}. See DXClusterProvider for an example of force=true usage on reconnect.",
        "files": ["src/network/NetworkManager.cpp", "src/services/DXClusterProvider.cpp"]
      },
      {
        "id": "libpredict_observer_required",
        "severity": "medium",
        "component": "satellite",
        "symptom": "OrbitPredictor::observe() returns all zeros or crashes",
        "cause": "libpredict requires both an observer location AND orbital elements to be set before any observation or pass prediction. If you call observe() without calling setObserver() and loadTLE() first, libpredict returns invalid data or segfaults.",
        "fix": "Always check OrbitPredictor::isReady() before calling observe(), nextPass(), or groundTrack(). isReady() returns true only if both observer and TLE are loaded. Set observer location early (in main.cpp after loading config) so all predictors share the same QTH.",
        "files": ["src/core/OrbitPredictor.cpp", "src/ui/SatPanel.cpp"]
      },
      {
        "id": "config_manager_init",
        "severity": "medium",
        "component": "config",
        "symptom": "Config not persisted, or config file created in wrong directory (e.g., /tmp instead of ~/.hamclock/)",
        "cause": "ConfigManager::init() must be called before load() or save(). init() resolves the XDG config directory path and creates ~/.hamclock/ if it doesn't exist. If you skip init(), save() will fail silently or write to a temporary directory.",
        "fix": "Call configMgr.init() at the top of main() before ANY config access. Check the return value — if false, the config directory couldn't be created (permissions issue). Log configMgr.configPath() during startup to verify the correct path.",
        "files": ["src/core/ConfigManager.cpp", "src/main.cpp"]
      },
      {
        "id": "wsjt_x_not_implemented",
        "severity": "low",
        "component": "dxcluster",
        "symptom": "WSJT-X UDP mode doesn't work, spots not appearing",
        "cause": "DXClusterProvider has a TODO for WSJT-X UDP parsing (line 285). The provider detects WSJT-X magic bytes (0xADBCCBDA) but doesn't parse the binary format yet. This is a partial feature.",
        "fix": "Either implement WSJT-X binary parsing (see WSJT-X NetworkMessage.hpp for format) or set dxClusterUseWSJTX=false in config and use Telnet cluster instead. WSJT-X integration is tracked as a future enhancement.",
        "files": ["src/services/DXClusterProvider.cpp"]
      },
      {
        "id": "aurora_data_sharing",
        "severity": "low",
        "component": "map",
        "symptom": "Aurora overlay on map doesn't appear even though AuroraProvider is fetching data",
        "cause": "MapWidget has TODO to share aurora JSON from NOAAProvider (line 985). Currently, MapWidget would re-fetch aurora data itself, but the integration isn't complete. AuroraProvider fetches the data but MapWidget doesn't know how to access it.",
        "fix": "Pass std::shared_ptr<AuroraHistoryStore> to MapWidget constructor so it can read aurora data from the shared store. Update MapWidget::renderAuroraOverlay() to use the store instead of re-fetching. This is a known integration gap.",
        "files": ["src/ui/MapWidget.cpp", "src/services/NOAAProvider.cpp", "src/core/AuroraHistoryStore.h"]
      },
      {
        "id": "windows_uptime_not_implemented",
        "severity": "low",
        "component": "general",
        "symptom": "TimePanel shows 'Up --' on Windows instead of system uptime",
        "cause": "getSystemUptime() in TimePanel.cpp has a TODO for Windows implementation (line 28). Linux uses /proc/uptime, macOS uses sysctl, but Windows equivalent (GetTickCount64) isn't implemented yet.",
        "fix": "Add Windows-specific code using GetTickCount64() and convert to days/hours/minutes format. This is a cosmetic feature with low priority.",
        "files": ["src/ui/TimePanel.cpp"]
      },
      {
        "id": "debug_api_ifdef",
        "severity": "medium",
        "component": "build",
        "symptom": "/debug/* endpoints return 404 even though code exists",
        "cause": "All debug endpoints in WebServer.cpp are wrapped in #ifdef ENABLE_DEBUG_API. This is OFF by default in release builds for security (debug endpoints allow state injection and widget introspection).",
        "fix": "To enable debug API, add -DENABLE_DEBUG_API to CMake flags or set ENABLE_DEBUG_API=1 in your build environment. For development builds, this is recommended. For production, keep it disabled to prevent information disclosure.",
        "files": ["src/network/WebServer.cpp", "CMakeLists.txt"]
      }
    ]
  },

  "api_examples": {
    "description": "Working curl commands for every WebServer endpoint. Base URL is http://localhost:8080 by default (configurable port).",
    "categories": {
      "core": {
        "description": "Core application endpoints",
        "endpoints": [
          {
            "endpoint": "/",
            "method": "GET",
            "description": "Live web interface with auto-refreshing screenshot and keyboard/mouse input",
            "curl": "curl http://localhost:8080/",
            "notes": "Opens in browser. Uses /live.jpg for display and /set_touch for click injection. Refresh rate defaults to 500ms (2 FPS)."
          },
          {
            "endpoint": "/live.jpg",
            "method": "GET",
            "description": "Current screenshot as JPEG (for automation, monitoring, or remote display)",
            "curl": "curl http://localhost:8080/live.jpg --output screenshot.jpg",
            "notes": "Updated every 250ms when requested. Quality=70. Used by the web UI for live updates."
          },
          {
            "endpoint": "/screen",
            "method": "GET",
            "description": "Screen power management (blank/unblank) and sleep prevention settings",
            "curl": "curl 'http://localhost:8080/screen?blank=1'\ncurl 'http://localhost:8080/screen?blank=0'\ncurl 'http://localhost:8080/screen?prevent=on'\ncurl 'http://localhost:8080/screen'",
            "notes": "?blank=1 powers off display (Linux: vcgencmd + xset dpms). ?prevent=on disables screen saver. No params returns JSON status."
          }
        ]
      },
      "input_injection": {
        "description": "Remote input control endpoints (keyboard and mouse simulation)",
        "endpoints": [
          {
            "endpoint": "/set_touch",
            "method": "GET",
            "description": "Inject mouse click at relative coordinates (0.0-1.0)",
            "curl": "curl 'http://localhost:8080/set_touch?rx=0.5&ry=0.5'",
            "notes": "rx/ry are relative coords (0.5, 0.5 = center). Simulates mouse down + up. Used by web UI."
          },
          {
            "endpoint": "/set_char",
            "method": "GET",
            "description": "Inject keyboard character or named key",
            "curl": "curl 'http://localhost:8080/set_char?k=A'\ncurl 'http://localhost:8080/set_char?k=Enter'\ncurl 'http://localhost:8080/set_char?k=Backspace'\ncurl 'http://localhost:8080/set_char?k=Escape'",
            "notes": "Supports printable chars and named keys: Enter, Backspace, Tab, Escape, ArrowLeft/Right/Up/Down, Delete, Home, End."
          }
        ]
      },
      "configuration": {
        "description": "Configuration query and update endpoints",
        "endpoints": [
          {
            "endpoint": "/get_config.txt",
            "method": "GET",
            "description": "Retrieve current configuration (callsign, grid, theme, lat/lon)",
            "curl": "curl http://localhost:8080/get_config.txt",
            "notes": "Returns plain text key-value pairs. Useful for scripts that need to read config."
          },
          {
            "endpoint": "/set_config",
            "method": "GET",
            "description": "Update configuration parameters",
            "curl": "curl 'http://localhost:8080/set_config?call=K4DRW&grid=EM75'\ncurl 'http://localhost:8080/set_config?theme=dark&lat=35.5&lon=-82.5'",
            "notes": "Params: call, grid, theme, lat, lon. Changes are saved to config.json immediately."
          },
          {
            "endpoint": "/get_de.txt",
            "method": "GET",
            "description": "Get DE (home) station info: callsign, grid, lat, lon",
            "curl": "curl http://localhost:8080/get_de.txt",
            "notes": "Returns DE_Callsign, DE_Grid, DE_Lat, DE_Lon in plain text."
          },
          {
            "endpoint": "/get_dx.txt",
            "method": "GET",
            "description": "Get DX station info: grid, lat, lon, distance (km), bearing (degrees)",
            "curl": "curl http://localhost:8080/get_dx.txt",
            "notes": "Returns DX_Grid, DX_Lat, DX_Lon, DX_Dist_km, DX_Bearing. If no DX set, returns 'DX not set'."
          },
          {
            "endpoint": "/set_mappos",
            "method": "GET",
            "description": "Programmatically set DE or DX position by lat/lon (returns computed grid square)",
            "curl": "curl 'http://localhost:8080/set_mappos?lat=35.5&lon=-82.5&target=de'\ncurl 'http://localhost:8080/set_mappos?lat=51.5&lon=-0.1&target=dx'",
            "notes": "Params: lat (float), lon (float), target (de|dx). Returns JSON with {target, lat, lon, grid}. Auto-calculates Maidenhead grid."
          },
          {
            "endpoint": "/get_time.txt",
            "method": "GET",
            "description": "Get current UTC time in ISO 8601 format",
            "curl": "curl http://localhost:8080/get_time.txt",
            "notes": "Returns 'Clock_UTC YYYY-MM-DDTHH:MM:SS Z'. Useful for time sync verification."
          }
        ]
      },
      "debug_api": {
        "description": "Debug and introspection endpoints (require ENABLE_DEBUG_API compile flag)",
        "endpoints": [
          {
            "endpoint": "/debug/widgets",
            "method": "GET",
            "description": "JSON dump of all registered widgets with bounds, actions, and debug data",
            "curl": "curl http://localhost:8080/debug/widgets | jq",
            "notes": "Returns {widgetName: {rect: [x,y,w,h], actions: [...], data: {...}}}. Essential for automated testing and debugging."
          },
          {
            "endpoint": "/debug/click",
            "method": "GET",
            "description": "Click a widget action by semantic name (automation-friendly alternative to pixel coordinates)",
            "curl": "curl 'http://localhost:8080/debug/click?widget=SetupScreen&action=save_button'",
            "notes": "Widget must implement getActions() and getActionRect(). Clicks the center of the action's rect. Returns 404 if widget/action not found."
          },
          {
            "endpoint": "/debug/type",
            "method": "GET",
            "description": "Type a full text string (alternative to multiple /set_char calls)",
            "curl": "curl 'http://localhost:8080/debug/type?text=Hello%20World'",
            "notes": "Injects SDL_TEXTINPUT events for each character. URL-encode spaces and special chars."
          },
          {
            "endpoint": "/debug/keypress",
            "method": "GET",
            "description": "Press a named key (enter, escape, tab, arrows, f11, etc.)",
            "curl": "curl 'http://localhost:8080/debug/keypress?key=enter'\ncurl 'http://localhost:8080/debug/keypress?key=f11'\ncurl 'http://localhost:8080/debug/keypress?key=escape'",
            "notes": "Supports: enter, tab, escape, backspace, delete, left, right, up, down, home, end, space, f11."
          },
          {
            "endpoint": "/debug/watchlist/add",
            "method": "GET",
            "description": "Add callsign to watchlist",
            "curl": "curl 'http://localhost:8080/debug/watchlist/add?call=W1AW'",
            "notes": "Adds callsign to WatchlistStore. Panel will highlight matching spots. Useful for automated testing."
          },
          {
            "endpoint": "/debug/store/set_solar",
            "method": "GET",
            "description": "Override solar data for testing (SFI, K-index, sunspot number)",
            "curl": "curl 'http://localhost:8080/debug/store/set_solar?sfi=150&k=5&sn=80'",
            "notes": "Injects test data into SolarDataStore. Params: sfi, k, sn. Useful for testing space weather displays without waiting for real data."
          },
          {
            "endpoint": "/debug/performance",
            "method": "GET",
            "description": "Performance metrics (FPS, uptime, port)",
            "curl": "curl http://localhost:8080/debug/performance | jq",
            "notes": "Returns JSON: {fps: N, port: N, running_since: seconds}. FPS is updated every frame."
          },
          {
            "endpoint": "/debug/health",
            "method": "GET",
            "description": "Health check for all data providers (ok status, last success timestamp, errors)",
            "curl": "curl http://localhost:8080/debug/health | jq",
            "notes": "Returns JSON: {ProviderName: {ok: bool, lastError: string, lastSuccess: ISO8601}}. Use for monitoring and alerting."
          },
          {
            "endpoint": "/debug/logs",
            "method": "GET",
            "description": "Log file location info",
            "curl": "curl http://localhost:8080/debug/logs | jq",
            "notes": "Returns info about log file path (~/.hamclock/hamclock.log) and stderr (journalctl). Not actual log contents."
          }
        ]
      }
    },
    "authentication_note": "SECURITY WARNING: All control endpoints (/set_*, /debug/*) are currently UNAUTHENTICATED. Do not expose WebServer to the public internet without a reverse proxy (nginx, Caddy) providing TLS + Basic Auth. For local development on localhost:8080, this is safe. For production, use Tailscale, VPN, or firewall rules to restrict access.",
    "cors_note": "CORS is not enabled. If you need to access the API from a web app on a different origin, add CORS headers in WebServer.cpp or use a reverse proxy to add them."
  }
}
